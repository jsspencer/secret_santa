#!/usr/bin/python
'''Randomly assign secret santas: each person in a group is randomly assigned
someone else in the group (other than themselves) for whom to buy a gift.

santa_file is a simple ini file.  The santas section contains all the people in
the group, with the name and value pairs representing the person's name and
their email address respectively.  If the email functionality is not used, then
the email addresses can be left blank.  For example:

[santas]
Joe Bloggs = joe.bloggs@example.net
Fred Bloggs = fred.bloggs@example.net

If emails need to be sent to the secret santas with their assignment, then the
email section must also be given with an email account :

[email]
sender = email address to send emails from
smtp_server = SMTP server used by the email account to send emails.
smtp_port = port of smtp server.  Default: 587.
authenticate = True if connection to the SMTP server needs to be authenticated
               using TLS and a password (requested interactively).
               Default: False.
subject = subject of the email.  Default: Secret Santa assignment.

For example, if sending the emails from a gmail account, then smtp_server
should be smtp.gmail.com, smtp_port 587 and authenticate set to True.'''
# copyright (c) 2012 James Spencer.
# All rights reserved.
#
# Modified BSD License; see LICENSE for more details

try:
    import configparser
except ImportError:
    # using python 2
    import ConfigParser as configparser
import copy
import getpass
import optparse
import random
import smtplib
import sys

class Person:
    '''Class to hold basic information about a person.

name: person's name
email: person's email address
'''
    def __init__(self, name, email=None):
        self.name = name
        self.email = email
    def __hash__(self):
        return hash((self.name, self.email))
    def __eq__(self, other):
        if isinstance(other, Person):
            return (self.name, self.email) == (other.name, other.email)
        else:
            raise NotImplementedError

class SantaEmailer:
    '''Class for emailing Secret Santa emails.

sender: email address used to send the emails to the secret santas.
smtp_server: address of the SMTP server of the sender's email address.
smtp_port: port of the SMTP server.
authenticate: if True, then connect to the SMTP server using TLS and login
              using a password.  The password is requested interactively at
              connection time.
subject: subject of email.'''
    def __init__(self, sender, smtp_server, smtp_port=587, authenticate=False,
                 subject='Secret Santa assignment'):
        self.sender = sender
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
        self.authenticate = authenticate
        self.subject = subject
        self._session = None
    def connect(self):
        '''Connect to SMTP server.'''
        self._session = smtplib.SMTP(self.smtp_server, self.smtp_port)
        if self.authenticate:
            passwd = getpass.getpass('Enter SMTP password: ')
            self._session.starttls()
            self._session.login(self.sender, passwd)
    def disconnect(self):
        '''Disconnect from SMTP server.'''
        self._session.quit()
    def send(self, santa, recipient):
        '''Send email to a secret santa

santa: Person object of the secret santa.
recipient: Person object of the person for whom santa needs to buy a present.
'''
        body = '''Hi!

Thanks for taking part in the secret santa scheme!

You have been assigned to buy a present for: %s (%s).

Please don't reply to this email without removing its contents in order to keep
the secret.

---
Created by secret_santa (https://github.com/jsspencer/secret_santa).
''' % (recipient.name, recipient.email)

        headers = '''From: %s
To: %s
Subject: %s''' % (self.sender, santa.email, self.subject)

        email = '%s\n%s' % (headers, body)

        self._session.sendmail(self.sender, santa.email, email)

def assign_secret_santas(people, emailer=None, send_email=False, verbose=True):
    '''Assign each person at random to give and receive a gift.

people: list of Person objects, each representing a secret santa.  Each person
is randomly assigned to get a present for someone else in the list.

emailer: SantaEmailer object used to send emails.
send_email: if true, send emails to all secret santas with the person they've
            been assigned.
verbose: if true, print secret santa assignments to screen.
'''

    # Ensure everyone is only entered once.
    people = list(set(people))

    # Put people in a random order.  This essentially removes the bias
    # discussed below.
    random.shuffle(people)

    unassigned = copy.copy(people)

    pairs = []
    for i in range(len(people)):

        santa = people[i]

        # Who is still needs to be assigned a secret santa?
        potential_recipients = copy.copy(unassigned)
        # Not allowed to give to themselves!
        try:
            potential_recipients.remove(santa)
        except ValueError:
            pass

        if i == len(people)-2 and people[-1] in potential_recipients:
            # Only two people left and the last person is still to be assigned.
            # This santa *must* be assigned to the last person.
            # (Note that this condition, whilst simple and fast, leads to a
            # slightly biased distribution for a given order of people.  For
            # a true random selection we need to enumerate all allowed
            # combinations and then uniformly select one, but that leads to an
            # O(N!) algorithm rather than an O(N) algorithm.)
            recipient = people[-1]
        else:
            # Select a random recipient...
            recipient = potential_recipients[
                                random.randint(0, len(potential_recipients)-1)
                                            ]

        pairs.append((santa, recipient))

        unassigned.remove(recipient)

    if verbose:
        santa_col_name = 'Secret Santa' 
        recipient_col_name = 'Recipient'
        longest_name_len = max(len(person.name) for person in people)
        table_format = ('%%-%is  |  %%-%is' %
                            (max(longest_name_len, len(santa_col_name)),
                             max(longest_name_len, len(recipient_col_name)))
                       )
        header = table_format % (santa_col_name, recipient_col_name)
        print(header)
        print('='*len(header))
        for (santa, recipient) in pairs:
            print(table_format % (santa.name, recipient.name))

    if send_email:
        emailer.connect()
        for (santa, recipient) in pairs:
            emailer.send(santa, recipient)
        emailer.disconnect()

def read_config(config_file):
    '''Read configuration from config_file.

See top-level doc string for the format of the configuration file.

returns: (people,)
    people: list of people (each a Person object) taking part in secret santa.
'''

    conf = configparser.RawConfigParser()
    conf.optionxform = str

    conf.read(config_file)

    # Get all the people doing secret santa 
    people = []
    for (name, email) in conf.items(section='santas'):
        people.append(Person(name, email))

    if conf.has_section('email'):
        sender = conf.get('email', 'sender')
        smtp_server = conf.get('email', 'smtp_server')
        if conf.has_option('email', 'smtp_port'):
            smtp_port = conf.get('email', 'smtp_port')
        else:
            smtp_port = 587
        if conf.has_option('email', 'authenticate'):
            authenticate = conf.getboolean('email', 'authenticate')
        else:
            authenticate = False
        if conf.has_option('email', 'subject'):
            subject = conf.get('email', 'subject')
        else:
            subject = 'Secret Santa assignment'
        emailer = SantaEmailer(sender, smtp_server, smtp_port, authenticate,
                               subject)
    else:
        emailer = None

    return (people, emailer)

def parse_cmdline_args(args):
    '''Parse command line arguments.

args: list of command-line arguments and options.
'''
    parser = optparse.OptionParser(usage='secret_santa [options] santa_file')
    parser.add_option('--help-long', dest='help_long', default=False,
                      action='store_true', help='Print out a long help message '
                      'including information about the santas config file.')
    parser.add_option('-q', '--quiet', dest='verbose', default=True,
                      action='store_false', help='Do not print secret santa '
                      'assignments to screen.  Default: false.')
    parser.add_option('-s', '--send-email', dest='send_email', default=False,
                      action='store_true', help='Send emails to the secret '
                      'santas with their assignment.  Default: false')

    (options, args) = parser.parse_args(args)

    if options.help_long:
        parser.print_help()
        print(__doc__)
        sys.exit(1)
    if len(args) != 1:
        parser.print_usage()
        sys.exit(1)

    return (options, args[0])

def main(args):
    '''main routine for running secret_santa.

args: list of command-line arguments and options.
'''
    (options, config_file) = parse_cmdline_args(args)
    (people, emailer) = read_config(config_file)
    assign_secret_santas(people, emailer, options.send_email, options.verbose)

if __name__ == '__main__':

    main(sys.argv[1:])
