#!/usr/bin/python
'''Randomly assign secret santas: each person in a group is randomly assigned
someone else in the group (other than themselves) for whom to buy a gift.

santa_file is a simple ini file.  The santas section contains all the people in
the group, with the name and value pairs representing the person's name and
their email address respectively.  If the email functionality is not used, then
the email addresses can be left blank.  For example:

[santas]
Joe Bloggs = joe.bloggs@example.net
Fred Bloggs = fred.bloggs@example.net

If emails need to be sent to the secret santas with their assignment, then the
email section must also be given with an email account :

[mailgun]
domain = mailgun domain to use
key = mailgun API key
'''
# copyright (c) 2012 James Spencer.
# All rights reserved.
#
# Modified BSD License; see LICENSE for more details

try:
    import configparser
except ImportError:
    # using python 2
    import ConfigParser as configparser
import copy
import getpass
import optparse
import random
import requests
import sys

class Person:
    '''Class to hold basic information about a person.

name: person's name
email: person's email address
'''
    def __init__(self, name, email=None):
        self.name = name
        self.email = email
    def __hash__(self):
        return hash((self.name, self.email))
    def __eq__(self, other):
        if isinstance(other, Person):
            return (self.name, self.email) == (other.name, other.email)
        else:
            raise NotImplementedError

def mailgun_send(mailgun, santa, recipient):
    '''Send email to a secret santa

santa: Person object of the secret santa.
recipient: Person object of the person for whom santa needs to buy a present.
'''
    body = '''Hi!

Thanks for taking part in the secret santa scheme!

You have been assigned to buy a stocking for: %s (%s).

Please don't reply to this email without removing its contents in order to keep
the secret.

---
Created by secret_santa (https://github.com/jsspencer/secret_santa).
''' % (recipient.name, recipient.email)

    return requests.post(
        "https://api.mailgun.net/v3/%s/messages" % mailgun['domain'],
        auth=("api", mailgun['key']),
        data={"from": "Secret Santa <mailgun@%s>" % mailgun['domain'],
              "to": [santa.email],
              "subject": "Secret Santa assignment",
              "text": body})

def assign_secret_santas(people, mailgun=None, send_email=False, verbose=True):
    '''Assign each person at random to give and receive a gift.

people: list of Person objects, each representing a secret santa.  Each person
is randomly assigned to get a present for someone else in the list.

mailgun: mailgun api and key.
send_email: if true, send emails to all secret santas with the person they've
            been assigned.
verbose: if true, print secret santa assignments to screen.
'''

    # Ensure everyone is only entered once.
    people = list(set(people))

    # Put people in a random order.  This essentially removes the bias
    # discussed below.
    random.shuffle(people)

    unassigned = copy.copy(people)

    pairs = []
    for i in range(len(people)):

        santa = people[i]

        # Who is still needs to be assigned a secret santa?
        potential_recipients = copy.copy(unassigned)
        # Not allowed to give to themselves!
        try:
            potential_recipients.remove(santa)
        except ValueError:
            pass

        if i == len(people)-2 and people[-1] in potential_recipients:
            # Only two people left and the last person is still to be assigned.
            # This santa *must* be assigned to the last person.
            # (Note that this condition, whilst simple and fast, leads to a
            # slightly biased distribution for a given order of people.  For
            # a true random selection we need to enumerate all allowed
            # combinations and then uniformly select one, but that leads to an
            # O(N!) algorithm rather than an O(N) algorithm.)
            recipient = people[-1]
        else:
            # Select a random recipient...
            recipient = potential_recipients[
                                random.randint(0, len(potential_recipients)-1)
                                            ]

        pairs.append((santa, recipient))

        unassigned.remove(recipient)

    if verbose:
        santa_col_name = 'Secret Santa' 
        recipient_col_name = 'Recipient'
        longest_name_len = max(len(person.name) for person in people)
        table_format = ('%%-%is  |  %%-%is' %
                            (max(longest_name_len, len(santa_col_name)),
                             max(longest_name_len, len(recipient_col_name)))
                       )
        header = table_format % (santa_col_name, recipient_col_name)
        print(header)
        print('='*len(header))
        for (santa, recipient) in pairs:
            print(table_format % (santa.name, recipient.name))

    if send_email:
        print('sending email...')
        #for (santa, recipient) in pairs:
            #mailgun_send(mailgun, santa, recipient)

def read_config(config_file):
    '''Read configuration from config_file.

See top-level doc string for the format of the configuration file.

returns: (people,)
    people: list of people (each a Person object) taking part in secret santa.
'''

    conf = configparser.RawConfigParser()
    conf.optionxform = str

    conf.read(config_file)

    # Get all the people doing secret santa 
    people = []
    for (name, email) in conf.items(section='santas'):
        people.append(Person(name, email))

    mailgun = {}
    if conf.has_section('mailgun'):
        mailgun['domain'] = conf.get('mailgun', 'domain')
        mailgun['key'] = conf.get('mailgun', 'key')

    return (people, mailgun)

def parse_cmdline_args(args):
    '''Parse command line arguments.

args: list of command-line arguments and options.
'''
    parser = optparse.OptionParser(usage='secret_santa [options] santa_file')
    parser.add_option('--help-long', dest='help_long', default=False,
                      action='store_true', help='Print out a long help message '
                      'including information about the santas config file.')
    parser.add_option('-q', '--quiet', dest='verbose', default=True,
                      action='store_false', help='Do not print secret santa '
                      'assignments to screen.  Default: false.')
    parser.add_option('-s', '--send-email', dest='send_email', default=False,
                      action='store_true', help='Send emails to the secret '
                      'santas with their assignment.  Default: false')

    (options, args) = parser.parse_args(args)

    if options.help_long:
        parser.print_help()
        print(__doc__)
        sys.exit(1)
    if len(args) != 1:
        parser.print_usage()
        sys.exit(1)

    return (options, args[0])

def main(args):
    '''main routine for running secret_santa.

args: list of command-line arguments and options.
'''
    (options, config_file) = parse_cmdline_args(args)
    (people, mailgun) = read_config(config_file)
    assign_secret_santas(people, mailgun, options.send_email, options.verbose)

if __name__ == '__main__':

    main(sys.argv[1:])
